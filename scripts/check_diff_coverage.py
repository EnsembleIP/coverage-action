#!/usr/bin/env python3
"""Script to check code coverage on only the files changed in a PR.

This provides a more focused view of coverage for new/modified code.
"""

import json
import os
import sys
import xml.etree.ElementTree as ET
from typing import TypedDict, cast


class CoverageData(TypedDict):
    """Type definition for coverage data."""

    covered: int
    total: int
    percentage: float


class FileCoverage(TypedDict):
    """Type definition for per-file coverage."""

    file: str
    coverage: float
    covered: int
    total: int


def parse_coverage(xml_path: str) -> dict[str, CoverageData]:
    """Parse coverage.xml and return coverage data per file."""
    tree = ET.parse(xml_path)  # nosec B314 - coverage.xml is generated by pytest-cov in CI
    root = tree.getroot()

    coverage_data: dict[str, CoverageData] = {}

    # Navigate through packages and classes to find file-level coverage
    for package in root.findall(".//package"):
        for cls in package.findall(".//class"):
            filename = cls.attrib.get("filename", "")
            if filename:
                # Get line coverage for this file
                lines = cls.findall(".//line")
                total_lines = len(lines)
                covered_lines = sum(1 for line in lines if int(line.attrib.get("hits", 0)) > 0)

                if total_lines > 0:
                    coverage_pct = (covered_lines / total_lines) * 100
                    coverage_data[filename] = CoverageData(
                        covered=covered_lines,
                        total=total_lines,
                        percentage=coverage_pct,
                    )

    return coverage_data


def validate_threshold(min_coverage: float) -> None:
    """Validate the minimum coverage threshold."""
    if not (0.0 <= min_coverage <= 100.0):  # noqa: PLR2004
        raise ValueError("min_coverage must be between 0 and 100")


def load_changed_files_payload(payload: str) -> object:
    """Parse changed-files payload, handling common escaping/double-encoding."""
    # `tj-actions/changed-files` (and some workflows) may produce values that look like:
    #   [\"a.py\",\"b.py\"]
    # i.e. a JSON array whose quotes were escaped for transport. That is *not* valid JSON,
    # and `json.loads` fails at column 2 (the first backslash). Be permissive here.
    try:
        data: object = json.loads(payload)
    except json.JSONDecodeError:
        p = payload.strip()

        # Case 1: array-looking payload with escaped quotes: [\"...\"] -> ["..."]
        if '\\"' in p and p.startswith("["):
            data = json.loads(p.replace('\\"', '"'))
        # Case 2: JSON string that itself contains JSON (double-encoded): "[\"...\"]"
        elif p.startswith('"') and p.endswith('"'):
            data = json.loads(json.loads(p))
        else:
            raise

    # Some pipelines give us a JSON string containing the array; decode one more time.
    if isinstance(data, str):
        try:
            data = json.loads(data)
        except json.JSONDecodeError:
            data = []
    return data


def get_changed_files(changed_files_json: str) -> list[str]:
    """Get list of changed Python files from GitHub."""
    try:
        files: list[str]
        with open(changed_files_json, encoding="utf-8") as f:
            raw = f.read()
        data = load_changed_files_payload(raw)
        # Handle both list and dict formats
        if isinstance(data, list):
            files = cast("list[str]", data)
        elif isinstance(data, dict) and "files" in data:
            files = cast("list[str]", data["files"])
        else:
            files = []
        return [f for f in files if f.endswith(".py")]
    except FileNotFoundError:
        print("Changed files JSON not found", file=sys.stderr)
        return []
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}", file=sys.stderr)
        return []


def calculate_diff_coverage(
    coverage_data: dict[str, CoverageData], changed_files: list[str]
) -> tuple[float | None, list[FileCoverage]]:
    """Calculate coverage only for changed files."""
    # Normalize paths in a cross-platform and report-generator-friendly way.
    def norm(p: str) -> str:
        p = p.replace("\\", "/")
        if p.startswith("./"):
            p = p[2:]
        return os.path.normpath(p).replace("\\", "/")

    normalized_coverage_data = {norm(f): data for f, data in coverage_data.items()}
    normalized_changed_files = {norm(f) for f in changed_files}

    total_covered = 0
    total_lines = 0
    file_coverages: list[FileCoverage] = []
    processed_files: set[str] = set()

    for changed_file in normalized_changed_files:
        if changed_file in processed_files:
            continue

        data = normalized_coverage_data.get(changed_file)
        if data is None:
            # Fallback: some coverage generators store paths relative to a different root.
            # If there is exactly one suffix match, use it.
            matches = [
                k
                for k in normalized_coverage_data
                if k.endswith(f"/{changed_file}") or changed_file.endswith(f"/{k}")
            ]
            if len(matches) == 1:
                data = normalized_coverage_data[matches[0]]

        if data is not None:
            total_covered += data["covered"]
            total_lines += data["total"]
            file_coverages.append(
                FileCoverage(
                    file=changed_file,
                    coverage=data["percentage"],
                    covered=data["covered"],
                    total=data["total"],
                )
            )
            processed_files.add(changed_file)

    if total_lines == 0:
        return None, []

    overall_coverage = (total_covered / total_lines) * 100
    return overall_coverage, file_coverages


def write_github_summary(
    diff_coverage: float, min_coverage: float, file_coverages: list[FileCoverage], passed: bool
) -> None:
    """Write diff coverage report to GitHub Actions step summary."""
    summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
    if not summary_file:
        return

    with open(summary_file, "a", encoding="utf-8") as f:
        f.write("\n### Diff Coverage Report (Changed Files Only)\n\n")
        f.write("| Metric | Value |\n")
        f.write("|---|---:|\n")
        f.write(f"| Diff coverage | {diff_coverage:.2f}% |\n")
        f.write(f"| Minimum required | {min_coverage:.2f}% |\n")
        f.write(f"| Files matched | {len(file_coverages)} |\n\n")
        f.write(f"**Status:** {'PASSED' if passed else 'FAILED'}\n")
        if not passed:
            f.write(f"\nDiff coverage {diff_coverage:.2f}% is below {min_coverage:.2f}%.\n\n")

        if file_coverages:
            f.write("<details>\n<summary>Per-file coverage</summary>\n\n")
            f.write("| File | Coverage | Lines |\n")
            f.write("|------|----------|-------|\n")
            for fc in file_coverages:
                f.write(
                    f"| `{fc['file']}` | {fc['coverage']:.1f}% | {fc['covered']}/{fc['total']} |\n"
                )
            f.write("\n</details>\n")


def write_github_annotation(diff_coverage: float, min_coverage: float, passed: bool) -> None:
    """Write GitHub Actions annotation."""
    if passed:
        print(
            f"::notice title=Diff coverage check passed ({diff_coverage:.2f}%)::"
            f"Diff coverage {diff_coverage:.2f}% meets required {min_coverage:.2f}% threshold"
        )
    else:
        print(
            f"::error title=Diff coverage check failed ({diff_coverage:.2f}%)::"
            f"Diff coverage {diff_coverage:.2f}% is below required {min_coverage:.2f}% threshold"
        )


def set_github_output(diff_coverage: float) -> None:
    """Set GitHub Actions output variable."""
    output_file = os.environ.get("GITHUB_OUTPUT")
    if output_file:
        with open(output_file, "a", encoding="utf-8") as f:
            f.write(f"diff_coverage={diff_coverage:.2f}\n")


def main() -> None:
    """Main function to check diff code coverage on changed files."""
    required_args = 2
    if len(sys.argv) < required_args + 1:
        print(
            "Usage: check_diff_coverage.py <coverage.xml> <changed_files.json> [min_coverage]",
            file=sys.stderr,
        )
        sys.exit(1)

    coverage_xml = sys.argv[1]
    changed_files_json = sys.argv[2]
    default_min_coverage = 90.0
    try:
        min_coverage = float(sys.argv[3]) if len(sys.argv) > required_args else default_min_coverage
        validate_threshold(min_coverage)
    except ValueError as e:
        print(f"Invalid min_coverage: {e}", file=sys.stderr)
        sys.exit(2)

    # Parse coverage data
    try:
        coverage_data = parse_coverage(coverage_xml)
    except Exception as e:
        print(f"Error parsing coverage file: {e}", file=sys.stderr)
        sys.exit(1)

    # Get changed files
    changed_files = get_changed_files(changed_files_json)

    if not changed_files:
        print("No Python files changed in this PR")
        # Write to summary that no files changed
        summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
        if summary_file:
            with open(summary_file, "a", encoding="utf-8") as f:
                f.write("\n### Diff Coverage Report (Changed Files Only)\n\n")
                f.write("No Python files changed in this PR.\n")
        sys.exit(0)

    # Calculate diff coverage
    diff_coverage, file_coverages = calculate_diff_coverage(coverage_data, changed_files)

    if diff_coverage is None:
        print("No coverage data found for changed files")
        summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
        if summary_file:
            with open(summary_file, "a", encoding="utf-8") as f:
                f.write("\n### Diff Coverage Report (Changed Files Only)\n\n")
                f.write(f"No coverage data found for {len(changed_files)} Python file(s).\n")
        print("::notice title=Diff coverage not computed::No coverage data found for changed files")
        sys.exit(0)

    passed = diff_coverage >= min_coverage

    # Output for GitHub Actions
    set_github_output(diff_coverage)
    write_github_summary(diff_coverage, min_coverage, file_coverages, passed)
    write_github_annotation(diff_coverage, min_coverage, passed)

    # Print to console
    print(f"Diff Coverage: {diff_coverage:.2f}%")
    print(f"Minimum Required: {min_coverage:.2f}%")
    print(f"Files Changed: {len(file_coverages)}")
    print("\nPer-file coverage:")
    for fc in file_coverages:
        print(f"  {fc['file']}: {fc['coverage']:.2f}% ({fc['covered']}/{fc['total']} lines)")

    print(f"\nStatus: {'PASSED' if passed else 'FAILED'}")

    sys.exit(0 if passed else 1)


if __name__ == "__main__":
    main()
